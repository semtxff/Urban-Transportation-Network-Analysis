In transportstop.py
We first import 'Enum' to define the enum type. 'Auto' automatically assigns values to enumeration members. 'csv' module for reading and writing CSV files.
Secondly, the ZoneType enumeration defines four regional types: 'RESIDENTIAL', 'COMMERCIAL', 'INDUSTRIAL' and 'MIXED'. Use 'auto()' to automatically assign an increasing value to each enumeration member.
The TransportStop class represents a traffic station with the attributes stop_id, name, latitude, longitude, and zone_type. The '__init__' method is used to initialize the object, where 'zone_type' must be an instance of the 'ZoneType' enumeration type, otherwise a 'ValueError' exception is raised. The '__str__' method returns a string representation of the object, showing the ID, name, latitude, longitude, and region type of the site. The '__repr__' method returns a detailed representation of the object for debugging and output purposes. The '__lt__' method defines the rules for comparing objects according to 'stop_id'.
Let the read_transport_stops_from_csv function accept a filename filename, read the data from the CSV file and create a list of TransportStop objects. Use 'csv.dictreader' to read the CSV file, with each row of data as a dictionary 'row'. Try to get start_stop_id (start site ID), end_stop_id (end site ID), and distance (distance) from row, and create a TransportStop object and add it to the stops list. If the value cannot be converted to an integer or floating point number, a 'ValueError' exception is caught and an error message is printed.
Finally, in the main program, when the script is run directly '(__name__ == "__main__")', the filename of the CSV file 'urban_transport_network_routes.csv' is specified. The 'read_transport_stops_from_csv' function is called to get the site object list 'transport_stops'. Traverse the transport_stops list and print each site object, displaying a string representation of the site (defined by the __str__ method).
To summarize, in transportstop.py, we show how to use enumerations and classes to model the types of sites and zones in an urban transportation network, and create site objects by reading CSV files. It also provides a basic framework that can be further extended to process and analyze complex traffic network data.
In read_csv.py
We first imported 'os' for operating system related functions such as getting file paths.
sys is used to add or adjust the module search path of the Python interpreter. 'pandas as pd' is used for data processing, especially reading and manipulating CSV files.
Then use 'os.path.abspath(__file__)' to get the absolute path of the current script file.
The 'os.path.dirname()' function is used to get the directory part of the path.
'project_root' is set to the project root directory, which is the parent of the directory where the current script file is located.
'sys.path.append(project_root)' adds the project root directory to the system path so that modules within the project can be imported.
Then import the 'ZoneType' enumeration and the 'TransportStop' class from Transportstop.py.
The 'read_stops_from_csv' function then accepts a parameter 'file_path', indicating the path of the CSV file to be read. Use 'pd.read_csv(file_path)' to read the contents of the CSV file and store them in the 'data' variable. Iterate over each row of data, create an instance of the TransportStop object, and convert each row into a property of the object. 'ZoneType[row['zone_type'].upper()]' converts the value of the 'zone_type' column to uppercase and sets the 'zone_type' attribute based on the value of the 'ZoneType' enumeration. If the file is not found, catch the 'FileNotFoundError' exception and print an error message, then return an empty list [].
The path of the last CSV file to be read is stored in the 'csv_file_path' variable. Call the read_stops_from_csv(csv_file_path) function and store the returned list of site objects in the transport_stops variable.
To summarize, in read_csv.py, we use the 'pandas' library to read CSV file data, combined with custom class and enumeration types, to achieve the transformation of urban traffic site data into objectified site information.
In directed_graph.py
We first imported 'networkx' for network analysis and 'matplotlib'. 'pyplot' for plotting, and 'pandas' for data processing.
We then define a dictionary 'node_labels' that maps the node numbers to the corresponding site names.
Once this is done, use pandas to read two CSV files containing latitude and longitude information for the site (stops_df) and distance information between the sites (routes_df). Create another DiGraph object G and use DiGraph() to indicate that it is a digraph.
Then use the data in 'stops_df' to add nodes, each node uses the site ID as the identification, and the latitude and longitude as the node attribute 'pos'. Add a directed edge using data from 'routes_df', where the start and end nodes are specified by 'start_stop_id' and 'end_stop_id', and the weight of the edge is indicated by 'distance'.
Creates a dictionary label that maps each node to the corresponding site name, using the node ID if none is defined.
Finally, use 'nx.get_node_attributes()' to get the node's location attribute 'pos'. Use the 'nx.draw()' function to draw a directed graph, specifying the position of the node, whether to display the node label, the node label content, the node size, the node color, the font size and color, and the display of the arrow. Set the title of the graph with 'plt.title()' and display the graph with 'plt.show()'. Calculate the degree centrality of each node in graph G, which represents the relative importance of the number of node connections in the overall network. Find the node with the greatest centrality, and then output the site name and node number for that node.
To summarize, in directed_graph.py, we create and plot a directed graph using 'NetworkX' and 'Matplotlib' to show the connections and distances between stations in the urban transportation network. It builds the graph structure by reading the data in the CSV file and presents the visual results using the location information of the nodes and custom node labels.
In find routes.py
These libraries are used for building and visualizing network graphics, as well as processing data. Then get the path of the current script file, and add the project root directory to the system path, so that the custom modules and data files in the project can be correctly imported. Then we import the graph 'G' in the custom module named 'directed_graph', node labels' node_labels', labels' labels', node position 'pos', And 'DataFrames stops_df' and 'routes_df' to store site and route data. We use the data in stops_df and routes_df to build the graph G, where the site is the node, the route is the directed edge, and the distance is the weight of the edge. Create a recursive function that looks up all paths from the start node to the target node in the graph 'G_dict' and returns a list of paths. Convert graph 'G' to dictionary representation 'G_dict' for easy use by path search function 'find_paths'. Find all paths from 'Chatelet' to 'Bastille' according to the predefined node label. Prints out all found paths to the console. Finally, 'NetworkX' and 'Matplotlib' are used to draw a directed graph with node positions, labels, edge weights, and display it visually.
To sum up, in find routes.py, we integrate the functions of data import, graph construction, path search and visual display, which is suitable for traffic network analysis and visualization.
In shortest_path.py
First import the necessary libraries and define the node number and the corresponding site name. Then read the site data from the CSV file urban_transport_network_stops.csv, which contains the longitude and latitude information of the site. Then the route data is read from urban_transport_network_routes.csv, including the start and end stations of the route, and the distance information of the route. Create a digraph object 'G'. Iterate over the site data and route data, adding the site as a node to the graph 'G', adding the route as a directed edge and the distance as the weight of the edge. The Dijkstra algorithm is used to calculate the shortest path length from node 1 (Chatelet) to all other nodes, weighted by the distance of the edges. Output the shortest path length from Chatelet to each node, using the 'node_labels' dictionary to convert the node number to the corresponding site name. The Dijkstra algorithm is used to compute the shortest path from Chatelet to each node and output the list of nodes in the path. Finally, NetworkX and Matplotlib are used to draw a directed graph 'G'. The node position is specified by 'pos', the node labels are specified by' labels', and the node size, color, font size, color and arrow style are also customized and displayed.
To summarize, we have integrated data import, graph building, shortest path calculation, and visual presentation capabilities in shortest_path.py to analyze and present the traffic network structure and its routing information.
In test_transportstop.py
First import the unittest module for writing and running tests, the csv in the standard library for handling CSV files, and the os and sys for path operations and module import Settings. Gets the directory of the current script file and adds the project root directory to the system path so that the modules in the project can be imported. Import the TransportStop class defined in ToolBox, the ZoneType enumeration type, and the read_transport_stops_from_csv function for reading traffic site information from a CSV file. Write the test class 'TestTransportStop', 'TestTransportStop' inherited from 'unittest.TestCase', Two test methods, test_stop_creation and test_invalid_zone_type, are included. The 'test_stop_creation' method tests the ability to create a TransportStop object and uses the assertion 'self.assertEqual' to verify that the created property values are as expected. The 'test_invalid_zone_type' method tests whether a 'ValueError' exception is raised when an invalid 'zone_type' parameter is passed. The read_transport_stops_from_csv function is defined to read traffic station information from a CSV file. Use the 'csv.dictreader' object to read the CSV file line by line and attempt to convert the data of each line to an integer or floating point number. Create a TransportStop object and add it to the stops list, catching an exception and printing an error message if you encounter a value error. Finally, 'unittest.main()' will execute all test methods and output the test results.
To summarize, in test_transportstop.py, we use the 'unittest' module to unittest the creation and property setting of the traffic station class 'TransportStop', as well as the functions to read and process CSV files.
In test_read_csv.py
First import the necessary libraries and modules, then get the path to the current script file and add the project root directory to the system path so that the custom modules can be properly imported. The read_stops_from_csv function in the custom module is imported, which is used to read the site data in the CSV file, and the TransportStop class and ZoneType enumeration types are imported, which are used to verify the format of the site data read. Create a test class that inherits from unittest.TestCase to write methods to unittest the read_stops_from_csv function. In the 'setUp' method, the resources or test data required for the test are set up, where the CSV file path for the test is specified. The test method 'test_read_stops_from_csv_file_not_found' is written to test when a non-existent CSV file path is passed in. Call the read_stops_from_csv function, expecting to return an empty list because the file does not exist. Use the 'self.assertEqual' assertion method to verify that the actual returned 'stops' is indeed an empty list to verify that the function behaves correctly when dealing with non-existent files. The test method 'test_read_stops_from_csv_valid_file' is written to test when a valid CSV file path is passed in. Call the read_stops_from_csv function, expect to return a list of stops with a length greater than 0, that is, ensure that multiple stops have been successfully read. Use the 'self.assertIsInstance' assertion method to verify that each 'stop' returned is an instance of the TransportStop class to verify that the data type returned by the function is as expected. Set the 'tearDown' method to clean up resources after the test executes. There are no resources to clean up for now. Finally, 'unittest.main()' will execute all the test methods and output the test results.
To summarize, in test_read_csv.py, we use the unittest module to unittest the function that reads the site data in the CSV file to ensure that the function handles and returns the expected result correctly under different circumstances.
In test_directed_graph.py
We first import the necessary libraries and modules, and then create a test class that inherits from 'unittest.TestCase' to indicate that we want to write unit tests. In the 'setUp' method, the test environment is set up. Virtual CSV data is created using 'StringIO' to simulate site data (' stops_data ') and route data (' routes_data ') respectively. It also defines a node label dictionary 'node_labels' that maps node numbers to site names. The test method test_network_graph was written to test the construction of traffic network graph and degree centrality calculation, reading station data and route data from virtual CSV data. A directed graph G is created and nodes and edges are added by traversing the site data and route data. Use the 'node_labels' dictionary to label nodes. The degree centrality of the graph 'G' is calculated and the sites with the highest degree of centrality are found. Using the 'self.assertEqual' assertion method, verify that the most central node is labeled "Chatelet" and that its node number is 1. Finally, use 'unittest.main()' to execute all test methods and output test results.
To sum up, in test_directed_graph.py, we use unittest framework to unittest the construction and analysis function of the traffic network to ensure the correctness and reliability of the code.
In test_find_routes.py
First import the necessary libraries and modules, then get the path to the current script file and add the project root directory to the system path so that the custom modules can be properly imported. Import node_labels and G objects in the custom module directed_graph for building and manipulating directed graphs. Create a test class that inherits from unittest.TestCase to write unit tests for pathfinding functionality. Write the test method test_find_paths to test all the simple paths from Chatelet to Bastille. Use the nx.all_simple_paths function provided by NetworkX to get all the simple paths from start_node to end_node. Use the self.assertGreater assertion method to ensure that at least one path exists. You can further verify the contents and order of specific paths, for example, define the expected_paths list, and check whether the expected path is found by loop and comparing the node labels of the paths. Use self.assertTrue. If the expected path is found, the test passes. Otherwise, an error message is displayed, showing the expected path and the actual found path. Finally, use 'unittest.main()' to execute all test methods and output test results.
To summarize, in our test_find_routes.py, we use the unittest module to unittest the path lookup function to ensure the accuracy and expected behavior of the path lookup.
In test_shortest_path.py
 first imports the unittest module, networkx library for graph theory operations, and pandas library for processing data in CSV files. Then create a test class that inherits from 'unittest.TestCase' to write methods for unit testing the functionality of the urban transportation network. Set up the 'setUp' method and do the initialization work in the 'setUp' method: use the 'pd.read_csv' to read the station data and route data of the urban traffic network. Create a directed graph 'self.G' and add nodes and edges based on site data and route data. Write the test method 'test_shortest_path_distance' to test the calculation of the shortest path distance. The 'nx.single_source_dijkstra_path_length' method is used to calculate the shortest path distance from node 1 (Chatelet) to other nodes. Using the 'self.assertEqual' assertion method, ensure that the distance from Chatelet to Gare de Lyon is 10.5 km. Write the test method 'test_shortest_path_nodes' to test the calculation of the shortest path nodes. The 'nx.single_source_dijkstra_path' method is used to compute the sequence of shortest path nodes from node 1 (Chatelet) to other nodes. assertEqual make sure that the node path from Chatelet to Gare de Lyon is [1, 2], that is, Chatelet goes through Gare de Lyon to reach the target node. Finally, we use 'unittest.main()' to execute all test methods and output the test results.
To summarize, in test_shortest_path.py, we use the 'unittest' module to unittest the graph structure of the urban traffic network to verify that its function of calculating the shortest path distance and node paths works as expected.